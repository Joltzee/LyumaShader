using UnityEngine;
using UnityEditor;
using System;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.IO;

namespace LyumaShaderSkin {

    public class ParsedShader {
        public Shader shader;
        public string filePath;
        public string surfaceTempFilePath;
        public string [] shaderLines;

        public const bool DEBUG_PARSER = false;

        public class Block {
            public ParsedShader shader;
            public enum Type {
                None = -1,
                ShaderName = 0,
                Properties = 1,
                CGInclude = 2,
                CGProgram = 3,
                GrabPass = 4,
                Pass = 5
            }
            public Type type;
            public int beginLineNum = -1;
            public int beginSkip = -1;
            public int endLineNum = -1;
            public int endSkip = -1;

            public Block (ParsedShader shader, Type type, int beginLine, int beginSkip, int endLine, int endSkip) {
                this.shader = shader;
                this.type = type;
                this.beginLineNum = beginLine;
                this.beginSkip = beginSkip;
                this.endLineNum = endLine;
                this.endSkip = endSkip;
            }
        }

        public class CGBlock : Block {
            public string vertFunction;
            public int vertFunctionPragmaLine = -1;
            public string geomFunction;
            public int geomFunctionPragmaLine = -1;
            public string fragFunction;
            public string domainFunction;
            public string hullFunction;
            public string surfFunction;
            public string surfVertFunction;
            public string vertReturnType;
            public string vertInputType;
            public bool originalSurfaceShader;
            public Dictionary<int, string> pragmas = new Dictionary<int, string>();
            public CGBlock (ParsedShader shader, Type type, int beginLine, int endLine) : base(shader, type, beginLine, 0, endLine, 0)
            {
                if (type != Type.CGProgram) {
                    return;
                }
                //for (int i = beginLine; i < endLine; i++) {
                Regex re = new Regex ("^\\s*(vertex|fragment|geometry|surface|domain|hull)\\s*(\\S+)\\s*.*(\\bvertex:(\\S+))?\\s*.*$");
                foreach (var pragmaLine in new PragmaIterator(shader.shaderLines.Skip(beginLine).Take(endLine - beginLine), beginLine) ) {
                    Match m = re.Match (pragmaLine.Key);
                    if (DEBUG_PARSER) { Debug.Log ("Found #pragma " + pragmaLine.Key + ": match " + m.Groups [1].Value + "," + m.Groups [2].Value + "," + m.Groups [3].Value + "," + m.Groups [4].Value); }
                    if (m != null && m.Success) {
                        string funcType = m.Groups [1].Value;
                        if (funcType.Equals ("surface")) {
                            surfFunction = m.Groups [2].Value;
                            if (m.Groups[4] != null) {
                                surfVertFunction = m.Groups [4].Value;
                            }
                            originalSurfaceShader = true;
                        } else if (funcType.Equals("vertex")) {
                            vertFunction = m.Groups [2].Value;
                            vertFunctionPragmaLine = pragmaLine.Value;
                        } else if (funcType.Equals ("fragment")) {
                            fragFunction = m.Groups [2].Value;
                        } else if (funcType.Equals ("geometry")) {
                            geomFunction = m.Groups [2].Value;
                            geomFunctionPragmaLine = pragmaLine.Value;
                        } else if (funcType.Equals ("domain")) {
                            domainFunction = m.Groups [2].Value;
                        } else if (funcType.Equals ("hull")) {
                            hullFunction = m.Groups [2].Value;
                        }
                    }
                    pragmas.Add (pragmaLine.Value, pragmaLine.Key);
                }
                if (surfFunction != null) {
                    // TODO: for non-surface shaders, find the vertFUnction and pick out the return type.
                    vertReturnType = "v2f_" + surfFunction;
                    vertInputType = "appdata_full";
                    vertFunction = "vert_" + surfFunction; // will be autogenerated.
                } else {
                    Regex vertRe = new Regex ("\\b(\\S+)\\b\\s+" + vertFunction + "\\s*\\(\\s*(\\S*)\\b");
                    foreach (string lin in new CommentFreeIterator(shader.shaderLines.Skip (beginLine).Take (endLine - beginLine))) {
                        if (lin.IndexOf("// Surface shader code generated based on:", StringComparison.CurrentCulture) != -1) {
                            originalSurfaceShader = true;
                            /*vertReturnType = "v2f_surf";
                            vertInputType = "appdata_full";
                            break;*/
                        }
                        /*
                        int vertIndex = lin.IndexOf (" " + vertFunction + " ", StringComparison.CurrentCulture);
                        if (vertIndex != -1) {
                            vertReturnType = lin.Substring (0, vertIndex).Trim ();
                            int paren = lin.IndexOf ("(", vertIndex, StringComparison.CurrentCulture);
                            if (paren != -1) {
                                int space = lin.IndexOf (" ", paren);
                                if (space != -1) {
                                    vertInputType = lin.Substring (paren + 1, space - paren - 1).Trim();
                                }
                            }
                        }
                        */
                        Match m = vertRe.Match (lin);
                        if (m != null && m.Success) {
                            vertReturnType = m.Groups [1].Value;
                            vertInputType = m.Groups [2].Value;
                        }
                    }
                }
            }
            public string getVertReturnType () {
                return vertReturnType;
            }
            public bool isSurface() {
                return surfFunction != null;
            }
            public bool hasGeometry() {
                return geomFunction != null;
            }
        }

        public Block shaderNameBlock;
        public Block propertiesBlock;
        public List<Block> passes = new List<Block>();
        public List<CGBlock> cgBlocks = new List<CGBlock>();

        public ParsedShader(Shader shader) {
            this.shader = shader;
            this.filePath = getPath (shader);
            Parse ();
        }

        public ParsedShader (Shader shader, string realFilePath)
        {
            this.shader = shader;
            this.filePath = realFilePath;
            Parse ();
        }

        private enum ParseState {
            ShaderName = 0,
            Properties = 1,
            PropertiesBlock = 2,
            SubShader = 3,
            PassBlock = 4,
            SubShaderCG = 6,
            PassCG = 7
        }

        void Parse() {
            shaderLines = File.ReadAllLines (filePath);
            ParseState state = ParseState.ShaderName;
            ParseState lastState = ParseState.PassBlock;
            int braceLevel = 0;
            int lineNum = -1;
            int beginBraceLineNum = -1;
            int beginBraceSkip = -1;
            int beginCGLineNum = -1;
            Block.Type passType = Block.Type.None;
            Block.Type cgType = Block.Type.None;
            Regex programCGRegex = new Regex ("CGPROGRAM|CGINCLUDE");
            Regex passCGRegex = new Regex ("GrabPass|Pass|CGPROGRAM|CGINCLUDE");
            foreach (string line in new CommentFreeIterator(shaderLines)) {
                lineNum++;
                bool fallThrough = true;

                while (fallThrough) {
                    if (state != lastState) {
                        if (DEBUG_PARSER) { Debug.Log ("Line " + lineNum + ": state changed to " + state); }
                        lastState = state;
                    }
                    //Debug.Log ("Looking for state " + state + " on line " + lineNum);
                    fallThrough = false;
                    int lineSkip = 0;
                    switch (state) {
                    case ParseState.ShaderName: {
                            int shaderOff = line.IndexOf ("Shader", lineSkip, StringComparison.CurrentCulture);
                            if (shaderOff != -1) {
                                int firstQuote = line.IndexOf ('\"', shaderOff);
                                int secondQuote = line.IndexOf ('\"', firstQuote + 1);
                                if (firstQuote != -1 && secondQuote != -1) {
                                    shaderNameBlock = new Block (this, Block.Type.ShaderName, lineNum, firstQuote + 1, lineNum, secondQuote);
                                    fallThrough = true;
                                    state = ParseState.Properties;
                                }
                            }
                        }
                        break;
                    case ParseState.Properties: {
                            // Find beginning of Properties block
                            int shaderOff = line.IndexOf ("Properties", lineSkip, StringComparison.CurrentCulture);
                            if (shaderOff != -1) {
                                state = ParseState.PropertiesBlock;
                                passType = Block.Type.Properties;
                                lineSkip = shaderOff;
                                fallThrough = true;
                            }
                        }
                        break;
                    case ParseState.PropertiesBlock:
                    case ParseState.PassBlock: {
                            // Find end of Properties block
                            int i = 0;
                            while (lineSkip < line.Length && i < 10000) {
                                i++;
                                int openBrace = line.IndexOf ("{", lineSkip, StringComparison.CurrentCulture);
                                int closeBrace = line.IndexOf ("}", lineSkip, StringComparison.CurrentCulture);
                                Match m = null;
                                if (state == ParseState.PassBlock) {
                                    m = programCGRegex.Match (line, lineSkip);
                                }
                                //Debug.Log ("Looking for braces state " + state + " on line " + lineNum + "/" + lineSkip + " {}" + braceLevel + " open:" + openBrace + "/ close:" + closeBrace + " m.index " + (m == null ? -2 : m.Index));
                                if (m != null && m.Success && (closeBrace == -1 || m.Index < closeBrace) && (openBrace == -1 || m.Index < openBrace)) {
                                    string match = m.Value;
                                    if (DEBUG_PARSER) { Debug.Log ("Found " + match + " in Pass block line " + lineNum); }
                                    cgType = match.Equals ("CGINCLUDE") ? Block.Type.CGInclude : Block.Type.CGProgram;
                                    state = ParseState.PassCG;
                                    fallThrough = false;
                                    lineSkip = line.Length;
                                    beginCGLineNum = lineNum + 1;
                                    break;
                                } else if (closeBrace != -1 && (openBrace > closeBrace || openBrace == -1)) {
                                    lineSkip = closeBrace + 1;
                                    braceLevel--;
                                    if (braceLevel == 0) {
                                        Block b = new Block (this, passType, beginBraceLineNum, beginBraceSkip, lineNum, closeBrace);
                                        if (state == ParseState.PropertiesBlock) {
                                            propertiesBlock = b;
                                        } else if (state == ParseState.PassBlock) {
                                            passes.Add (b);
                                        }
                                        state = ParseState.SubShader;
                                        fallThrough = true;
                                        break;
                                    }
                                } else if (openBrace != -1 && (openBrace < closeBrace || closeBrace == -1)) {
                                    if (braceLevel == 0) {
                                        beginBraceLineNum = lineNum;
                                        beginBraceSkip = openBrace + 1;
                                    }
                                    braceLevel++;
                                    lineSkip = openBrace + 1;
                                } else {
                                    break;
                                }
                            }
                            if (i >= 9999) {
                                throw new Exception ("Loop overflow " + i + "in braces search " + lineNum + "/" + lineSkip + ":" + braceLevel);
                            }
                        }
                        break;
                    case ParseState.SubShader: {
                            Match m = null;
                            m = passCGRegex.Match (line, lineSkip);
                            if (m != null && m.Success) {
                                string match = m.Value;
                                if (match.Equals ("CGINCLUDE") || match.Equals ("CGPROGRAM")) {
                                    cgType = match.Equals ("CGINCLUDE") ? Block.Type.CGInclude : Block.Type.CGProgram;
                                    if (DEBUG_PARSER) { Debug.Log ("Found " + match + " in SubShader line " + lineNum + ": " + cgType); }
                                    state = ParseState.SubShaderCG;
                                    fallThrough = true;
                                    beginCGLineNum = lineNum + 1;
                                    break;
                                } else if (match.Equals ("GrabPass") || match.Equals ("Pass")) {
                                    state = ParseState.PassBlock;
                                    fallThrough = true;
                                    passType = match.Equals ("Pass") ? Block.Type.Pass : Block.Type.GrabPass;
                                    break;
                                }
                            }
                        }
                        break;
                    case ParseState.SubShaderCG:
                    case ParseState.PassCG:
                        int endCG = line.IndexOf ("ENDCG", lineSkip, StringComparison.CurrentCulture);
                        if (endCG != -1) {
                            if (DEBUG_PARSER) { Debug.Log ("Ending cg:" + cgType + " lines " + beginCGLineNum + "-" + lineNum); }
                            CGBlock b = new CGBlock (this, cgType, beginCGLineNum, lineNum);
                            passes.Add (b);
                            cgBlocks.Add (b);
                            state = (state == ParseState.SubShaderCG) ? ParseState.SubShader : ParseState.PassBlock;
                        }
                        // Look for modified tag, or end of shader, or custom editor.
                        break;
                    }
                }
            }
            foreach (Block b in passes) {
                CGBlock cgb = b as CGBlock;
                if (cgb != null || b.type == Block.Type.CGInclude||b.type == Block.Type.CGProgram) {
                    Debug.Log ("Shader has a " + b.type + " on lines " + b.beginLineNum + "-" + b.endLineNum +
                               " with vert:" + cgb.vertFunction + " geom:" + cgb.geomFunction + " surf:" + cgb.surfFunction +
                               " | vert accepts input " + cgb.vertInputType + " output " + cgb.vertReturnType);
                } else {
                    Debug.Log ("Shader has " + b.type + " block on lines " + b.beginLineNum + "-" + b.endLineNum);
                }
            }
        }
        
        public class CommentFreeIterator : IEnumerable<string> {
            private IEnumerable<string> sourceLines;
            public static string parserRemoveComments (string line, ref int comment)
            {
                int lineSkip = 0;
                while (true) {
                    //Debug.Log ("Looking for comment " + lineSkip);
                    int commentIdx;
                    if (comment == 1) {
                        commentIdx = line.IndexOf ("*/", lineSkip, StringComparison.CurrentCulture);
                        if (commentIdx != -1) {
                            line = new String (' ', (commentIdx + 2)) + line.Substring (commentIdx + 2);
                            lineSkip = commentIdx + 2;
                            comment = 0;
                        } else {
                            line = "";
                            break;
                        }
                    }
                    commentIdx = line.IndexOf ("//", lineSkip, StringComparison.CurrentCulture);
                    if (commentIdx != -1) {
                        line = line.Substring (0, commentIdx);
                        break;
                    }
                    commentIdx = line.IndexOf ("/*", lineSkip, StringComparison.CurrentCulture);
                    if (commentIdx != -1) {
                        int endCommentIdx = line.IndexOf ("*/", lineSkip, StringComparison.CurrentCulture);
                        if (endCommentIdx != -1) {
                            line = line.Substring (0, commentIdx) + new String (' ', (endCommentIdx + 2 - commentIdx)) + line.Substring (endCommentIdx + 2);
                            lineSkip = endCommentIdx + 2;
                        } else {
                            line = line.Substring (0, commentIdx);
                            comment = 1;
                            break;
                        }
                    } else {
                        break;
                    }
                }
                return line;
            }

            public CommentFreeIterator (IEnumerable<string> sourceLines)
            {
                this.sourceLines = sourceLines;
            }
            public IEnumerator<string> GetEnumerator ()
            {
                int comment = 0;
                foreach (string xline in sourceLines) {
                    string line = parserRemoveComments (xline, ref comment);
                    yield return line;
                }
            }
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator () { return GetEnumerator (); }
        }

        public class PragmaIterator : IEnumerable<KeyValuePair<string, int>> {
            private IEnumerable<string> sourceLines;
            int startLine;
            public PragmaIterator (IEnumerable<string> sourceLines, int startLine)
            {
                this.sourceLines = sourceLines;
                this.startLine = startLine;
            }
            public IEnumerator<KeyValuePair<string, int>> GetEnumerator ()
            {
                Regex re = new Regex ("^\\s*#\\s*pragma\\s+(.*)$");
                //Regex re = new Regex ("^\\s*#\\s*pragma\\s+geometry\\s+\(\\S*\)\\s*$");
                int ln = startLine - 1;
                foreach (string xline in sourceLines) {
                    string line = xline;
                    ln++;
                    /*if (ln < startLine + 10) { Debug.Log ("Check line " + ln +"/" + line); }
                    line = line.Trim ();
                    if (line.StartsWith("#", StringComparison.CurrentCulture)) {
                        Debug.Log ("Check pragma " + ln + "/" + line);
                    }*/
                    if (re.IsMatch (line)) {
                        //Debug.Log ("Matched pragma " + line);
                        yield return new KeyValuePair<string, int> (re.Replace (line, match => match.Groups [1].Value), ln);
                    }
                }
            }
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator () { return GetEnumerator (); }
        }

        public bool hasSurfaceShader ()
        {
            foreach (CGBlock b in cgBlocks) {
                if (b.isSurface()) {
                    return true;
                }
            }
            return false;
        }

        public static string getPath (Shader shader)
        {
            if (shader == null) {
                return null;
            }
            string path = AssetDatabase.GetAssetPath (shader);
            if (path.StartsWith ("Resources/unity_builtin_extra", StringComparison.CurrentCulture) && "Standard".Equals (shader.name)) {
                string [] tmpassets = AssetDatabase.FindAssets ("StandardSimple");
                foreach (string guid in tmpassets) {
                    path = AssetDatabase.GUIDToAssetPath (guid);
                    if (path.IndexOf (".shader", StringComparison.CurrentCulture) != -1) {
                        break;
                    }
                }
            }
            // TODO: same for Legacy Shaders/Diffuse etc.
            return path;
        }

        public static string getTempPath (Shader shader, out string error)
        {
            string assetPath = getPath (shader);
            if (assetPath == null) {
                error = "No shader selected.";
                return null;
            }
            error = null;
            if (!assetPath.StartsWith ("Assets/", StringComparison.CurrentCulture)) {
                error = "Asset " + shader + " at path " + assetPath + " is not inside the Assets folder.";
                //EditorUtility.DisplayDialog ("GeomShaderGenerator", error, "OK", "");
                return null;
            }
            if (!File.Exists (assetPath)) {
                error = "Asset " + shader + " at path " + assetPath + " file does not exist.";
                return null;
            }
            string relativeAssetPath = assetPath.Substring (7);
            // TODO: Test in Unity 2017. This is likely to break in unity updates.
            // However, no public API is exposed to give us access to this file.
            string tempPath = "Temp/GeneratedFromSurface-" + shader.name.Replace ("/", "-") + ".shader";
            if (!File.Exists (tempPath)) {
                error = "Generated surface shader " + tempPath + " does not exist.\n\nPlease find the Surface shader line and click \"Show generated code\" before converting here.";
                return null;
            }
            return tempPath;
        }

    }

    public class GeomShaderGenerator : EditorWindow {

        public enum ShaderType {
            Simple = 0
        }

        ParsedShader windowShader;
        ShaderType genType;

        void SetShader (Shader shader)
        {
            if (shader == null) {
                windowShader = null;
            } else {
                windowShader = new ParsedShader (shader);
            }
        }


        [MenuItem ("CONTEXT/Shader/Generate Geometry Shader Simple")]
        static void GeomShaderGenerateSimpleCmd (MenuCommand command)
        {
            Shader s = command.context as Shader;
            Shader newS = GeomShaderGenerate (new ParsedShader(s), ShaderType.Simple);
        }

        [MenuItem ("CONTEXT/Shader/Generate Geometry Shader")]
        static void GeomShaderGenerateCmd (MenuCommand command)
        {
            Shader s = command.context as Shader;
            GeomShaderGenerator win = (GeomShaderGenerator)GetWindow (typeof (GeomShaderGenerator));
            win.SetShader (s);
            win.Show();
        }

        void OnGUI ()
        {
            Shader newShader = (Shader)EditorGUILayout.ObjectField (new GUIContent ("Shader", "Shader to edit"),
                                                                    windowShader == null ? null : windowShader.shader, typeof (Shader), true);
            if (windowShader == null && newShader != windowShader.shader) {
                SetShader (newShader);
            }
            if (windowShader == null) {
                EditorGUILayout.HelpBox ("Please select a shader.", MessageType.Info);
                return;
            }
            genType = (ShaderType)EditorGUILayout.EnumPopup("Generated shader type", genType);
            EditorGUILayout.Separator ();
            string surfacePath = windowShader == null ? null : windowShader.filePath;
            if (windowShader.hasSurfaceShader ()) {
                string err;
                surfacePath = ParsedShader.getTempPath (windowShader.shader, out err);
                if (surfacePath == null) {
                    EditorGUILayout.HelpBox (err, MessageType.Error);
                    if (GUILayout.Button ("Refresh")) {
                    }
                    return;
                }
            }
            EditorGUILayout.HelpBox (surfacePath, MessageType.None);
            if (GUILayout.Button ("Generate")) {
                Shader newS = GeomShaderGenerate (windowShader, genType);
                Close ();
            }
        }

        static Shader GeomShaderGenerate (ParsedShader s, ShaderType genType)
        {
            string shaderName = s.shader.name;
            string surfacePath = s.filePath;
            if (s.hasSurfaceShader ()) {
                string err;
                surfacePath = ParsedShader.getTempPath (s.shader, out err);
                if (surfacePath == null) {
                    EditorUtility.DisplayDialog ("GeomShaderGenerator", err, "OK", "");
                    return null;
                }
            }
            Debug.Log ("Starting to work on shader " + shaderName);
            Debug.Log ("Original path: " + s.filePath);
            Debug.Log ("Path: " + surfacePath);
            Shader ret = GeomShaderPath (new ParsedShader(s.shader, surfacePath), s.filePath, genType);
            EditorGUIUtility.PingObject (ret);
            return ret;
        }

        static Shader GeomShaderPath(ParsedShader s, string path, ShaderType genType) {


            string [] shader2dassets = AssetDatabase.FindAssets ("ShaderSkinBase");
            string includePath = "LyumaShader/ShaderSkin/ShaderSkinBase.cginc";
            foreach (string guid in shader2dassets) {
                Debug.Log ("testI: " + AssetDatabase.GUIDToAssetPath (guid));
                includePath = AssetDatabase.GUIDToAssetPath (guid);
                if (!includePath.Contains ("ShaderSkinBase.cginc")) {
                    continue;
                }
                if (!includePath.StartsWith ("Assets/", StringComparison.CurrentCulture)) {
                    EditorUtility.DisplayDialog ("Waifu2d", "This script at path " + includePath + " must be in Assets!", "OK", "");
                    return null;
                }
                includePath = includePath.Substring (7);
                break;
            }
            int numSlashes = 0;
            if (!path.StartsWith ("Assets/", StringComparison.CurrentCulture)) {
                EditorUtility.DisplayDialog ("Waifu2d", "Shader " + s.shader.name + " at path " + path + " must be in Assets!", "OK", "");
                return null;
            }
            string includePrefix = "";
            foreach (char c in path.Substring (7)) {
                if (c == '/') {
                    numSlashes++;
                    includePrefix += "../";
                }
            }
            includePath = includePrefix + includePath;
            foreach (ParsedShader.CGBlock cgBlock in s.cgBlocks) {
                Debug.Log ("Found surface shader pass! Input:" + cgBlock.vertInputType + " Output:" + cgBlock.vertReturnType);
                if (cgBlock.vertFunction != null && cgBlock.fragFunction != null && cgBlock.vertInputType != null && cgBlock.vertReturnType != null) {
                    string replaceStr = "//GeomShaderGenerator:" + genType + " generated!\n";
                    replaceStr +=
                        "#define VERT_FUNCTION " + cgBlock.vertFunction + "\n" +
                        "#define APPDATA_TYPE " + cgBlock.vertInputType + "\n" +
                        "#define VERT_TYPE " + cgBlock.vertReturnType + "\n";
                    if (cgBlock.hasGeometry ()) {
                        replaceStr += "#define GEOM_FUNCTION " + cgBlock.geomFunction + "\n";
                    }
                    replaceStr += "#include \"" + includePath + "\"\n";
                    replaceStr += "#pragma geometry shaderskin_geom\n";
                    replaceStr += "#pragma target 4.6\n";
                    s.shaderLines [cgBlock.endLineNum] = replaceStr + s.shaderLines [cgBlock.endLineNum];
                    if (cgBlock.geomFunction != null) {
                        Debug.LogError ("geom not yet implemented!");
                        s.shaderLines [cgBlock.vertFunctionPragmaLine] = "// GeomShaderGenerator:" + genType + " edited!\n//" +
                            s.shaderLines [cgBlock.vertFunctionPragmaLine];
                    }
                    s.shaderLines [cgBlock.vertFunctionPragmaLine] = "#pragma vertex shaderskin_noop_vert // GeomShaderGenerator:" + genType + " generated!\n//" +
                        s.shaderLines [cgBlock.vertFunctionPragmaLine];
                }
                foreach (var pragma in cgBlock.pragmas) {
                    if (pragma.Value.Trim().StartsWith("target", StringComparison.CurrentCulture)) {
                        s.shaderLines [pragma.Key] = "//" + s.shaderLines [pragma.Key];
                    }
                }
            }

            string epLine = s.shaderLines [s.propertiesBlock.beginLineNum];
            string propertiesAdd = "\n" +
                "        // GeomShaderGenerator Properties:\n" +
                "        [HDR] _MeshTex (\"Mesh Data\", 2D) = \"white\" {}\n" +
                "        _BoneCutoff (\"bone ranges to render\", Vector) = (0, 0, 0, 0)\n" +
                "        _rainbow_coef (\"Rainbow bone colors\", Range (0, 1)) = 0.0\n";
            epLine = epLine.Substring (0, s.propertiesBlock.beginSkip) + propertiesAdd + epLine.Substring (s.propertiesBlock.beginSkip);
            s.shaderLines [s.propertiesBlock.beginLineNum] = epLine;

            string shaderSuffix = "_" + genType; // FIXME: better name?

            string shaderLine = s.shaderLines [s.shaderNameBlock.beginLineNum];
            shaderLine = shaderLine.Substring (0, s.shaderNameBlock.endSkip) + shaderSuffix + shaderLine.Substring (s.shaderNameBlock.endSkip);
            s.shaderLines [s.shaderNameBlock.beginLineNum] = shaderLine;

            String dest = path.Replace (".shader", shaderSuffix + ".txt");
            String finalDest = path.Replace (".shader", shaderSuffix + ".shader");
            if (dest.Equals (path)) {
                EditorUtility.DisplayDialog ("Waifu2d", "Shader " + s.shader.name + " at path " + path + " does not have .shader!", "OK", "");
                return null;
            }
            Debug.Log ("Writing shader " + dest);
            Debug.Log ("Shader name" + s.shader.name + shaderSuffix);
            Debug.Log ("Original path " + path + " generatedPath " + s.filePath);
            StreamWriter writer = new StreamWriter (dest, false);
            writer.WriteLine ("// AUTOGENERATED by GeomShaderGenerator:" + genType + " at " + DateTime.UtcNow.ToString ("s") + "!");
            writer.WriteLine ("// Original source file: " + path);
            writer.WriteLine ("// This shader will not update automatically. Please regenerate if you change the original.");
            writer.WriteLine ("// WARNING: this shader uses relative includes. Unity might not recompile if ShaderSkinBase.cginc changes.");
            writer.WriteLine ("// If editing ShaderSkinBase.cginc, force a recompile by adding a space in here or regenerating.");
            for (int i = 0; i < s.shaderLines.Length; i++) {
                if (s.shaderLines [i].IndexOf ("CustomEditor", StringComparison.CurrentCulture) != -1) {
                    writer.WriteLine ("//" + s.shaderLines [i]);
                } else {
                    writer.WriteLine (s.shaderLines [i]);
                }
            }
            writer.Close ();
            FileUtil.ReplaceFile (dest, finalDest);
            try {
                FileUtil.DeleteFileOrDirectory (dest);
            } catch (Exception e) {
            }
            //FileUtil.MoveFileOrDirectory (dest, finalDest);
            AssetDatabase.ImportAsset (finalDest);
            return (Shader)AssetDatabase.LoadAssetAtPath (finalDest, typeof (Shader));
        }
    }
}
